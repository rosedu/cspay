/*
 * xls file implementation
 */

/**
 * \ingroup libspreadconv
 * \file xls.c
 * \author Cojocar Lucian
 * \brief xls file implementation
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "spreadconv.h"
#include "xls.h"
#include "utils.h"
#include "debug.h"

/**
 * Script file descriptor
 */
static FILE *f;

static int  open_script();
static void print_shabang();
static void print_import();
static void print_sheet(struct spreadconv_data *);
static void print_cell_styles(struct spreadconv_data *);
static void print_rc_styles(struct spreadconv_data *);
static void print_cell_data(struct spreadconv_data *);
static void print_save(char *);
static void close_script();
static void run_script(char *);

/**
 * Save \a spreadconv_data to a xls file
 * \param data data to convert
 * \return full path of created file or NULL if
 * an error occured
 */
char *
xls_create_spreadsheet(struct spreadconv_data *data)
{
	char *script_name;
	char *doc_name;
	script_name = malloc(512);
	if (!spreadconv_dir_name)
		spreadconv_dir_name = strdup("/tmp/");
	snprintf(script_name, 512, "%sspreadconv_pyXXXXXX", spreadconv_dir_name);
	if(!mktemp(script_name)) {
		fprintf(stderr, "mktemp\n");
		free(script_name);
		return NULL;
	}
	doc_name = malloc(512);
	snprintf(doc_name, 512, "%sspreadconv_xlsXXXXXX", spreadconv_dir_name);
	if (!mktemp(doc_name)) {
		fprintf(stderr, "mktemp\n");
		free(doc_name);
		free(script_name);
		return NULL;
	}
	doc_name = realloc(doc_name, strlen(doc_name) + 5);
	strcat(doc_name, ".xls");

	if(open_script(script_name)) {
		free(doc_name);
		free(script_name);
		return NULL;
	}
	print_shabang();
	print_import();
	print_sheet(data);
	print_cell_styles(data);
	print_rc_styles(data);
	print_cell_data(data);
	print_save(doc_name);
	close_script();
	run_script(script_name);

	free(script_name);
	return doc_name;
}

/**
 * Open a file and set file descriptor
 * \param file_name script name
 * \return 0 on succes, -1 on error
 */
static int
open_script(char *file_name)
{
	f = fopen(file_name, "wt");
	if (!f) {
		fprintf(stderr, "fopen_error");
		return -1;
	}
	return 0;
}

/**
 * Print Sha-bang
 */
static void
print_shabang()
{
	fprintf(f, "#!/usr/bin/env python\n");
	fprintf(f, "# -*- coding: utf-8 -*-\n");
	fprintf(f, "#Generated by libspreadconv\n");
	fprintf(f, "\n");
}

/**
 * Print imports
 */
static void
print_import()
{
	fprintf(f, "from pyExcelerator import *\n\n");
}

/**
 * Print sheet and workbook declarations
 */
static void
print_sheet(struct spreadconv_data *data)
{
	fprintf(f, "work_book = Workbook()\n");
	fprintf(f, "sheet = work_book.add_sheet(\'%s\')\n", data->name);
}

/**
 * Print cell styles
 * \param data \a spreadconv_data that contains cell styles
 */
static void
print_cell_styles(struct spreadconv_data *data)
{
	int i;
	struct spreadconv_cell_style *s;
	fprintf(f, "\n#####BEGIN_CELL_STYLES######\n");
	fprintf(f, "default_style = XFStyle()\n");

	if (!data->n_unique_cell_styles)
		return;
	fprintf(f, "cell_style_mappings = [");
	for (i = 0; i < data->n_unique_cell_styles; ++ i) {
		fprintf(f, "\'%s\', ", data->unique_cell_styles[i].name);
	}
	fseek(f, -2, SEEK_CUR);
	fprintf(f, "]\n");
	fprintf(f, "cell_style = []\n");

	s = data->unique_cell_styles;
	for (i = 0; i < data->n_unique_cell_styles; ++ i){
		fprintf(f, "###beg_style%d###\n", i);
		fprintf(f, "cell_style.append(XFStyle())\n");
		/* Alignments */
		if (s[i].valign || s[i].halign) {
			fprintf(f, "####beg_align###\n");
			fprintf(f, "cell_align%d = Alignment()\n", i);
			if (s[i].valign) {
				/* vertical alilgnment is set
				 */
				fprintf(f, "cell_align%d.vert = Alignment.", i);
				if (!strcmp(s[i].valign, "middle"))
					fprintf(f, "VERT_CENTER");
				else if (!strcmp(s[i].valign, "top"))
					fprintf(f, "VERT_TOP");
					else fprintf(f, "VERT_BOTTOM");
				fprintf(f, "\n");
			}
			if (s[i].halign) {
				/* horizontal alignment
				 */
				fprintf(f, "cell_align%d.horz = Alignment.", i);
				if (!strcmp(s[i].halign, "center"))
					fprintf(f, "HORZ_CENTER");
				else if (!strcmp(s[i].halign, "start"))
					fprintf(f, "HORZ_LEFT");
					else fprintf(f, "HORZ_RIGHT");
				fprintf(f, "\n");
			}
			fprintf(f, "cell_align%d.wrap = Alignment.WRAP_AT_RIGHT\n", i);
			fprintf(f, "cell_style[%d].alignment = cell_align%d\n", i, i);
			fprintf(f, "####end_align####\n");
		}
		/* Borders */
		if (s[i].border || s[i].border_top || s[i].border_bottom ||
			s[i].border_left || s[i].border_right) {
			fprintf(f, "####beg_border####\n");
			fprintf(f, "cell_border%d = Borders()\n", i);
			if (s[i].border) {
				fprintf(f, "cell_border%d.left = 0x%02X\n", i, bord_str2i(s[i].border));
				fprintf(f, "cell_border%d.right = 0x%02X\n", i, bord_str2i(s[i].border));
				fprintf(f, "cell_border%d.top = 0x%02X\n", i, bord_str2i(s[i].border));
				fprintf(f, "cell_border%d.bottom = 0x%02X\n", i, bord_str2i(s[i].border));
			} else {
				if (s[i].border_left) 
					fprintf(f, "cell_border%d.left = 0x%02X\n", i, bord_str2i(s[i].border_left));
				if (s[i].border_right) 
					fprintf(f, "cell_border%d.right = 0x%02X\n", i, bord_str2i(s[i].border_right));
				if (s[i].border_top) 
					fprintf(f, "cell_border%d.top = 0x%02X\n", i, bord_str2i(s[i].border_top));
				if (s[i].border_bottom) 
					fprintf(f, "cell_border%d.bottom = 0x%02X\n", i, bord_str2i(s[i].border_bottom));

			}
			fprintf(f, "cell_style[%d].borders = cell_border%d\n", i, i);
			fprintf(f, "###end_border###\n");
		}
		fprintf(f, "###end_style%d###\n", i);
	}
	fprintf(f, "#####END_CELL_STYLES######\n");
}

/**
 * Prin row and columns styles
 * \param data \a spreadconv_data that contains row and column
 * styles
 */
static void
print_rc_styles(struct spreadconv_data *data)
{
	fprintf(f, "###beg_rc_styles###\n");
	int i, j;
	for (j = 0; j < data->n_cols; ++ j) 
		if (data->col_styles[j]) {
			fprintf(f, "sheet.col(%d).width = 0x%06X\n", j,
				(int)col_str2i(data->col_styles[j]->size));
		}
	for (i = 0; i < data->n_rows; ++ i)
		if (data->row_styles[i]) {
			fprintf(f, "row_font%d = Font()\n", i);
			fprintf(f, "row_font%d.height = %d\n", i, 
				row_str2i(data->row_styles[i]->size));
			fprintf(f, "row_style%d = XFStyle()\n", i);
			fprintf(f, "row_style%d.font = row_font%d\n", i, i);
			fprintf(f, "sheet.row(%d).set_style(row_style%d)\n", i, i);
		}
	fprintf(f, "###end_rc_styles###\n");
}

/**
 * Print cell data and text
 * \param data \a spreadconv_data * that contains text
 */
static void
print_cell_data(struct spreadconv_data *data)
{
	int i, j;
	for (i = 0; i < data->n_rows; ++ i)
		for (j = 0; j < data->n_cols; ++ j) {
			if (data->cells[i][j].text) {
				fprintf(f, "sheet.write(%d, %d, u\'", i, j);
				py_print_esc(f, data->cells[i][j].text);
				if (data->cells[i][j].style) {
					fprintf(f, "\', cell_style[cell_style_mappings.index(\'%s\')])\n",
						data->cells[i][j].style->name);

				} else
					fprintf(f, "\', default_style)\n");
			} else 
				if (data->cells[i][j].style) {
					fprintf(f, "sheet.write(%d, %d, \'", i, j);
					fprintf(f, "\', cell_style[cell_style_mappings.index(\'%s\')])\n", 
						data->cells[i][j].style->name);
				}
		}
}

/**
 * Print "save sheet"
 */
static void
print_save(char *file_name)
{
	fprintf(f, "work_book.save(\'%s\')", file_name);
}

/**
 * Close script
 */
static void
close_script()
{
	fclose(f);
}

/**
 * Run script
 * \param sn script name
 */
static void
run_script(char *sn)
{
	char command[512];
	snprintf(command, 512, "python %s", sn);
	system(command);
}
